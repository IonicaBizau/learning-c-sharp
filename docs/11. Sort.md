# Sort

## Methods

 - `sort<T>(T[] a)`
 - `less<T>(T p, T q)`
 - `exch<T>(T[] a, int i, int j)`
 - `show<T>(T[] a)`
 - `isSorted(T[] a)`

## Implementation

 - using `less(...)` and `exch(...)` which are easy to implement because of `IComparable` (interface)
 - using `isSorted()` to check if the things are sorted
 - performance is important
   - interchanges
   - comparisons
   - how many times an element is accessed for write/read
  - memory
  - data types
   - any values supporting `IComparable`
   - `CompareTo()` should imlpement a total relation (reflexive, antisimetric, transitive)

## Sorting algorithms
### Selection Sort

 - find the lowest element, interchange it with the element on `k`th position (where `k` goes from `0` to `Length - 1`).
 - performance: `~N^2/2`, not depending on input data, element order

### Insertion Sort

 - move the element on the good place, where the things are already sorted
 - should move everything to right, creating space
 - `[0, i]` are sorted, but we don't know if their positions are final
 - when `i == length - 1`, the array is sorted
 - performance: `~N^2/4` comparisons, `~N^2/4` interchanges
 - the performance depends on input data

### Shell Sort

 - checks `V[i] vs V[i + h]` and interchanges them

  ```cs
  int h = 1;
  while (h < n / 3) {
      h = 3 * h + 1;
  }
  while (h > 1) {
      // ...
      h /= 3;
  }
  ```

 - hard to understand this! :warning: :smile:

### Merge Sort

 - based on merging two sorted arrays
